class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        sort(initial.begin(),initial.end());
        vector<vector<int>> v(graph.size());
        unordered_map<int,int> count;
        for(int i = 0;i<graph.size();i++) {
            for(int j = 0;j<graph[0].size();j++) {
                if(i == j)
                    continue;
                if(graph[i][j] == 1)
                    v[i].push_back(j);
            }
        }
        
        int st = 0;
        int base = 0;
        unordered_map<int,int> M;
        while(st != initial.size()) {
            if(M.count(initial[st]) != 0) {
                st++;
                continue;
            }
            int from = 0;
            vector<int> dq;
            dq.push_back(initial[st]);
            M[initial[st]] = base;
            while(from != dq.size()) {
                int to = dq.size();
                for(int i = from;i<to;i++) {
                    for(int j = 0;j<v[dq[i]].size();j++) {
                        if(M.count(v[dq[i]][j]) == 0) {
                            M[v[dq[i]][j]] = base;
                            dq.push_back(v[dq[i]][j]);
                        }
                    }
                }
                from = to;
            }
            count[base] = dq.size();
            base++;
            st++;
        }
        
        vector<vector<int>> res(graph.size());
        for(int i = 0;i<initial.size();i++) {
            res[M[initial[i]]].push_back(initial[i]);
        }
        int ret = INT_MAX;
        int c = INT_MAX;
        //for(int i = 0;i<res.size();i++) {
        //    cout << res[i].size();
        //}
        //for(auto iter = M.begin();iter != M.end();iter++) {
        //    cout << iter->first << iter->second <<endl;
        //}
        for(int i = 0;i<res.size();i++) {
            if(res[i].size() == 1) {
                if(ret == INT_MAX) {
                    ret = res[i][0];
                    c = count[i];
                }
                else if(count[i] > c || (count[i] == c && res[i][0] < ret)) {
                    ret = res[i][0];
                    c = count[i];
                }
            }
        }
        if(ret == INT_MAX)
            return initial[0];
        return ret;
    }
};